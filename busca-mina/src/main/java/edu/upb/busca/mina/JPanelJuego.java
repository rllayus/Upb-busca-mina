/*
 * Click nbfs://nbhost/SystemFileSystem/Templates/Licenses/license-default.txt to change this license
 * Click nbfs://nbhost/SystemFileSystem/Templates/GUIForms/JPanel.java to edit this template
 */
package edu.upb.busca.mina;

import edu.upb.busca.mina.bl.BuscaminasFuncional;
import edu.upb.busca.mina.bl.Celda;
import edu.upb.busca.mina.bl.EstadoJuego;
import edu.upb.busca.mina.bl.Tablero;

import javax.swing.*;
import java.awt.*;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;

/**
 * @author rlaredo
 */
public class JPanelJuego extends javax.swing.JPanel implements MouseListener {
    private static int FILAS = 10;
    private static int COLUMNAS = 10;
    private Tablero estadoActual;
    private static int MINAS = 10;

    /**
     * Creates new form JPanelJuego
     */
    public JPanelJuego(int filas, int columnas, int minas) {
        initComponents();
        FILAS = filas;
        COLUMNAS = columnas;
        MINAS = minas;
        estadoActual = BuscaminasFuncional.crearTableroInicial(FILAS, COLUMNAS, MINAS);
        this.addMouseListener(this);
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGap(0, 596, Short.MAX_VALUE)
        );
        layout.setVerticalGroup(
                layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                        .addGap(0, 443, Short.MAX_VALUE)
        );
    }// </editor-fold>//GEN-END:initComponents


    // Variables declaration - do not modify//GEN-BEGIN:variables
    // End of variables declaration//GEN-END:variables
    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        dibujarTablero(g, estadoActual);
    }

    @Override
    public void mouseClicked(MouseEvent e) {

    }

    @Override
    public void mousePressed(MouseEvent e) {

    }

    @Override
    public void mouseReleased(MouseEvent e) {
        if (SwingUtilities.isLeftMouseButton(e) || SwingUtilities.isRightMouseButton(e)) {
            manejarClic(e);
        }
    }

    @Override
    public void mouseEntered(MouseEvent e) {
    }

    @Override
    public void mouseExited(MouseEvent e) {
    }


    public void dibujarTablero(Graphics g, Tablero tablero) {
        // Definir los colores y fuentes para el dibujo
        final Color COLOR_CELDA_CUBIERTA = Color.LIGHT_GRAY;
        final Color COLOR_CELDA_REVELADA = new Color(220, 220, 220); // Gris claro
        final Color COLOR_MINA = Color.BLACK;
        final Color COLOR_BANDERA = Color.RED;
        final Font FUENTE_NUMERO = new Font("Arial", Font.BOLD, 18);

        int tamanioCelda = Math.min(getWidth() / tablero.columnas(), getHeight() / tablero.filas());

        // Iterar sobre cada celda del tablero
        for (int fila = 0; fila < tablero.filas(); fila++) {
            for (int columna = 0; columna < tablero.columnas(); columna++) {
                Celda celda = tablero.celdas()[fila][columna];

                // Coordenadas de la celda
                int x = columna * tamanioCelda;
                int y = fila * tamanioCelda;

                // Dibujar el fondo de la celda
                if (celda.estaRevelada()) {
                    g.setColor(COLOR_CELDA_REVELADA);
                } else {
                    g.setColor(COLOR_CELDA_CUBIERTA);
                }
                g.fillRect(x, y, tamanioCelda, tamanioCelda);

                // Dibujar el borde de la celda
                g.setColor(Color.GRAY);
                g.drawRect(x, y, tamanioCelda, tamanioCelda);

                // Dibujar el contenido de la celda si está revelada
                if (celda.estaRevelada()) {
                    if (celda.esMina()) {
                        g.setColor(COLOR_MINA);
                        g.fillOval(x + tamanioCelda / 4, y + tamanioCelda / 4, tamanioCelda / 2, tamanioCelda / 2);
                    } else if (celda.minasVecinas() > 0) {
                        g.setColor(getColorNumero(celda.minasVecinas()));
                        g.setFont(FUENTE_NUMERO);
                        String numero = String.valueOf(celda.minasVecinas());
                        int centroX = x + (tamanioCelda - g.getFontMetrics().stringWidth(numero)) / 2;
                        int centroY = y + (tamanioCelda + g.getFontMetrics().getAscent()) / 2;
                        g.drawString(numero, centroX, centroY);
                    }
                } else if (celda.tieneBandera()) {
                    // Dibujar una bandera si la celda tiene una
                    g.setColor(COLOR_BANDERA);
                    g.fillRect(x + tamanioCelda / 4, y + tamanioCelda / 4, tamanioCelda / 2, tamanioCelda / 2);
                }
            }
        }
    }

    // Método auxiliar para obtener el color del número de minas vecinas
    private Color getColorNumero(int numero) {
        return switch (numero) {
            case 1 -> Color.BLUE;
            case 2 -> Color.GREEN.darker();
            case 3 -> Color.RED;
            case 4 -> new Color(128, 0, 128); // Púrpura
            case 5 -> Color.ORANGE.darker();
            case 6 -> Color.CYAN.darker();
            case 7 -> Color.MAGENTA.darker();
            case 8 -> Color.BLACK;
            default -> Color.BLACK;
        };
    }


    private void manejarClic(MouseEvent e) {
        // 1. Calcular el tamaño de la celda
        int tamanioCelda = Math.min(getWidth() / estadoActual.columnas(), getHeight() / estadoActual.filas());

        // 2. Obtener la fila y columna del clic
        int x = e.getX();
        int y = e.getY();

        // Verificar que el clic esté dentro del tablero
        if (x >= 0 && x < estadoActual.columnas() * tamanioCelda && y >= 0 && y < estadoActual.filas() * tamanioCelda) {
            int fila = y / tamanioCelda;
            int columna = x / tamanioCelda;

            // 3. Aplicar la lógica funcional según el botón del ratón
            if (SwingUtilities.isLeftMouseButton(e)) {
                // Clic izquierdo: Revelar la celda
                estadoActual = BuscaminasFuncional.revelarCelda(estadoActual, fila, columna);
            } else if (SwingUtilities.isRightMouseButton(e)) {
                // Clic derecho: Colocar o quitar bandera
                estadoActual = BuscaminasFuncional.colocarBandera(estadoActual, fila, columna);
            }

            // 4. Repintar la UI para mostrar el nuevo estado del juego
            repaint();

            // 5. Verificar si el juego terminó
            if (estadoActual.estado() == EstadoJuego.PERDIDO) {
                // Lógica para mostrar el mensaje de "Game Over"
                JOptionPane.showMessageDialog(this, "¡Has perdido!", "Fin del juego", JOptionPane.ERROR_MESSAGE);
            }
        }
    }
}
